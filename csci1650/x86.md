# x86
## 1. General Purpose Registers (GPRs)

In 32-bit x86 (IA-32), there are **8 general purpose registers**:

* EAX, EBX, ECX, EDX
* ESI, EDI, EBP, ESP

### Subdivisions

The first four (EAX, EBX, ECX, EDX) are **special** because they can be accessed at smaller granularities:

* **EAX** → 32 bits

  * AX (lower 16 bits)
  * AH (high 8 bits of AX)
  * AL (low 8 bits of AX)

Same breakdown applies to EBX, ECX, EDX.
For example:

* `mov AL, 0x12` affects only the lowest byte of EAX.
* `mov AH, 0x34` affects bits 8–15 of EAX.
* `mov AX, 0x5678` writes the low 16 bits, leaving upper 16 unchanged.

The other four (ESI, EDI, EBP, ESP) **do not** have AH/AL-style subregisters. They are accessed only as:

* 32-bit: ESI, EDI, EBP, ESP
* 16-bit: SI, DI, BP, SP

### Example

```asm
mov eax, 0x12345678   ; eax = 12345678h
mov ax, 0x9ABC        ; eax = 12349ABCh
mov al, 0xEF          ; eax = 12349AEFh
mov ah, 0x01          ; eax = 123401EFh
```


## 2. Special Purpose Registers

Your diagram highlights two important ones:

* **EFLAGS**

  * A 32-bit status/control register.
  * Contains condition flags (CF, ZF, SF, OF, etc.) and control bits.
  * Example:

    * CF (Carry Flag) → set if arithmetic carry/borrow occurred.
    * ZF (Zero Flag) → set if result == 0.
    * SF (Sign Flag) → set if result is negative.
    * OF (Overflow Flag) → set if signed overflow occurred.

* **EIP** (Instruction Pointer)

  * Holds the address of the next instruction to execute.
  * Changes automatically after each instruction, or explicitly by jumps, calls, returns.


## 3. Why This Matters

* **Compiler use**: compilers map C variables into these registers for fast access.

* **Calling conventions**: some registers have special ABI roles.

  * Example: in 32-bit System V ABI:

    * EAX → return value
    * ECX, EDX → scratch (caller-saved)
    * ESI, EDI, EBP → callee-saved

* **Assembly optimization**: understanding partial registers (AL, AH, AX) is key for bit manipulations and performance tuning.


## 4. Common Pitfalls

* Writing to a smaller subregister (e.g., `AX`) does **not clear** the upper part of `EAX`.
  Example:

  ```asm
  mov eax, 0x12345678
  mov ax, 0x0000
  ; eax = 0x12340000  (upper 16 bits unchanged)
  ```
* But in x86-64, writing to the 32-bit subregister (e.g., `EAX`) **does clear** the upper 32 bits of RAX.

# x86 instruction set categories

## 1. Data Transfer Instructions

These move data between registers, memory, and the stack.

* Examples:

  * `mov eax, ebx`  → copy EBX into EAX
  * `xchg eax, ebx` → swap EAX and EBX
  * `push eax`      → push register onto stack
  * `pop ecx`       → pop top of stack into ECX

*Why important:* all programs spend a lot of time just shuffling data between registers and memory.


## 2. Arithmetic and Logic Instructions

Perform calculations or bitwise operations.

* Arithmetic:

  * `add eax, 5`
  * `sub ebx, ecx`
* Logic:

  * `and eax, 0xFF`
  * `or eax, ebx`
  * `xor eax, eax` → sets EAX to 0 (classic trick)
  * `not edx`

*Why important:* these update **EFLAGS** (e.g., Zero Flag, Carry Flag), which later control branches.


## 3. Control Instructions

These **change the flow of execution**, often by updating **EIP** (the instruction pointer).

* `call func` → push return address, jump to func
* `ret`       → pop return address, continue
* `jmp label` → unconditional jump
* `jcc label` → conditional jump (where `cc` = condition code, e.g., JE, JNE, JL, JG…)

*Why important:* together with flags, they make loops and if/else possible at machine level.


## 4. Miscellaneous Instructions

Useful odds and ends.

* `nop` → do nothing (useful for alignment, patching code)
* `enter`/`leave` → setup/teardown stack frames for functions
* `test eax, eax` → AND without storing result, just sets flags
* `cmp eax, ebx` → subtraction without storing result, just sets flags
* `int 0x80` or `syscall` → trigger system calls to the OS

*Why important:* these let you interact with the operating system and manage function calls.

## 5. Variable-Length Instructions

x86 instructions aren’t fixed length (unlike RISC).

* They can be **1 byte up to 15 bytes**.
* Operands can be 0, 1, 2, 3 (sometimes more with prefixes).
  Example:
* `nop` → 1 byte
* `mov eax, 0x12345678` → 5 bytes
* `jmp far ptr` → longer

This makes x86 powerful but harder for CPUs to decode efficiently.

˝
# x86 memory addressing modes

## 1. Direct Addressing

You use an **absolute memory address**.

```asm
mov $0x1, 0x1110     ; store constant 1 at memory location 0x1110
mov 0x2000, %eax     ; load the value at address 0x2000 into eax
```

* The number is literally treated as a memory address.
* Rarely used in real programs because absolute addresses are not relocatable (better with offsets and registers).


## 2. Indirect Addressing

You use **registers** to calculate where in memory to look.

### a) Base register only

```asm
mov $0x1, (%eax)   ; store 1 into memory at address [EAX]
```

* Here EAX is the **base register (BR)**.

### b) Base + displacement (offset)

```asm
mov %ebx, 0x10(%eax)  ; store EBX into memory at [EAX + 0x10]
```

* Offset (displacement) adds a constant to the base.

### c) Base + index + scale + displacement

```asm
mov 0x10(%eax, %ebx, 4), %edx
```

* Effective Address = `EAX + (EBX * 4) + 0x10`
* EAX = base register (BR)
* EBX = index register (IR)
* Scale = 1, 2, 4, or 8 (useful for array indexing)
* Offset = displacement constant (0x10 here)

This is extremely common in compiled code for accessing array elements and struct fields.


## 3. General Effective Address Formula

You wrote it in green:

```
EA = BR + IR * {1,2,4,8} + OFF
```

* BR = Base register (optional)
* IR = Index register (optional)
* Scale = multiplier (1, 2, 4, 8)
* OFF = constant displacement

Not all parts must be present. The CPU can decode any valid combination.


## 4. Real-World Example

Imagine a C array:

```c
int arr[10];
int i = 3;
int x = arr[i];
```

Compiler might generate:

```asm
mov eax, i
mov edx, arr
mov ecx, [edx + eax*4]   ; load arr[i] into ecx
```

* `edx` = base address of `arr`
* `eax` = index `i`
* `*4` = scale (because int = 4 bytes)
