# x86
## 1. General Purpose Registers (GPRs)

In 32-bit x86 (IA-32), there are **8 general purpose registers**:

* EAX, EBX, ECX, EDX
* ESI, EDI, EBP, ESP

### Subdivisions

The first four (EAX, EBX, ECX, EDX) are **special** because they can be accessed at smaller granularities:

* **EAX** ‚Üí 32 bits

  * AX (lower 16 bits)
  * AH (high 8 bits of AX)
  * AL (low 8 bits of AX)

Same breakdown applies to EBX, ECX, EDX.
For example:

* `mov AL, 0x12` affects only the lowest byte of EAX.
* `mov AH, 0x34` affects bits 8‚Äì15 of EAX.
* `mov AX, 0x5678` writes the low 16 bits, leaving upper 16 unchanged.

The other four (ESI, EDI, EBP, ESP) **do not** have AH/AL-style subregisters. They are accessed only as:

* 32-bit: ESI, EDI, EBP, ESP
* 16-bit: SI, DI, BP, SP

### Example

```asm
mov eax, 0x12345678   ; eax = 12345678h
mov ax, 0x9ABC        ; eax = 12349ABCh
mov al, 0xEF          ; eax = 12349AEFh
mov ah, 0x01          ; eax = 123401EFh
```


## 2. Special Purpose Registers

Your diagram highlights two important ones:

* **EFLAGS**

  * A 32-bit status/control register.
  * Contains condition flags (CF, ZF, SF, OF, etc.) and control bits.
  * Example:

    * CF (Carry Flag) ‚Üí set if arithmetic carry/borrow occurred.
    * ZF (Zero Flag) ‚Üí set if result == 0.
    * SF (Sign Flag) ‚Üí set if result is negative.
    * OF (Overflow Flag) ‚Üí set if signed overflow occurred.

* **EIP** (Instruction Pointer)

  * Holds the address of the next instruction to execute.
  * Changes automatically after each instruction, or explicitly by jumps, calls, returns.


## 3. Why This Matters

* **Compiler use**: compilers map C variables into these registers for fast access.

* **Calling conventions**: some registers have special ABI roles.

  * Example: in 32-bit System V ABI:

    * EAX ‚Üí return value
    * ECX, EDX ‚Üí scratch (caller-saved)
    * ESI, EDI, EBP ‚Üí callee-saved

* **Assembly optimization**: understanding partial registers (AL, AH, AX) is key for bit manipulations and performance tuning.


## 4. Common Pitfalls

* Writing to a smaller subregister (e.g., `AX`) does **not clear** the upper part of `EAX`.
  Example:

  ```asm
  mov eax, 0x12345678
  mov ax, 0x0000
  ; eax = 0x12340000  (upper 16 bits unchanged)
  ```
* But in x86-64, writing to the 32-bit subregister (e.g., `EAX`) **does clear** the upper 32 bits of RAX.

# x86 instruction set categories

## 1. Data Transfer Instructions

These move data between registers, memory, and the stack.

* Examples:

  * `mov eax, ebx`  ‚Üí copy EBX into EAX
  * `xchg eax, ebx` ‚Üí swap EAX and EBX
  * `push eax`      ‚Üí push register onto stack
  * `pop ecx`       ‚Üí pop top of stack into ECX

*Why important:* all programs spend a lot of time just shuffling data between registers and memory.


## 2. Arithmetic and Logic Instructions

Perform calculations or bitwise operations.

* Arithmetic:

  * `add eax, 5`
  * `sub ebx, ecx`
* Logic:

  * `and eax, 0xFF`
  * `or eax, ebx`
  * `xor eax, eax` ‚Üí sets EAX to 0 (classic trick)
  * `not edx`

*Why important:* these update **EFLAGS** (e.g., Zero Flag, Carry Flag), which later control branches.


## 3. Control Instructions

These **change the flow of execution**, often by updating **EIP** (the instruction pointer).

* `call func` ‚Üí push return address, jump to func
* `ret`       ‚Üí pop return address, continue
* `jmp label` ‚Üí unconditional jump
* `jcc label` ‚Üí conditional jump (where `cc` = condition code, e.g., JE, JNE, JL, JG‚Ä¶)

*Why important:* together with flags, they make loops and if/else possible at machine level.


## 4. Miscellaneous Instructions

Useful odds and ends.

* `nop` ‚Üí do nothing (useful for alignment, patching code)
* `enter`/`leave` ‚Üí setup/teardown stack frames for functions
* `test eax, eax` ‚Üí AND without storing result, just sets flags
* `cmp eax, ebx` ‚Üí subtraction without storing result, just sets flags
* `int 0x80` or `syscall` ‚Üí trigger system calls to the OS

*Why important:* these let you interact with the operating system and manage function calls.

## 5. Variable-Length Instructions

x86 instructions aren‚Äôt fixed length (unlike RISC).

* They can be **1 byte up to 15 bytes**.
* Operands can be 0, 1, 2, 3 (sometimes more with prefixes).
  Example:
* `nop` ‚Üí 1 byte
* `mov eax, 0x12345678` ‚Üí 5 bytes
* `jmp far ptr` ‚Üí longer

This makes x86 powerful but harder for CPUs to decode efficiently.

Àù
# x86 memory addressing modes

## 1. Direct Addressing

You use an **absolute memory address**.

```asm
mov $0x1, 0x1110     ; store constant 1 at memory location 0x1110
mov 0x2000, %eax     ; load the value at address 0x2000 into eax
```

* The number is literally treated as a memory address.
* Rarely used in real programs because absolute addresses are not relocatable (better with offsets and registers).


## 2. Indirect Addressing

You use **registers** to calculate where in memory to look.

### a) Base register only

```asm
mov $0x1, (%eax)   ; store 1 into memory at address [EAX]
```

* Here EAX is the **base register (BR)**.

### b) Base + displacement (offset)

```asm
mov %ebx, 0x10(%eax)  ; store EBX into memory at [EAX + 0x10]
```

* Offset (displacement) adds a constant to the base.

### c) Base + index + scale + displacement

```asm
mov 0x10(%eax, %ebx, 4), %edx
```

* Effective Address = `EAX + (EBX * 4) + 0x10`
* EAX = base register (BR)
* EBX = index register (IR)
* Scale = 1, 2, 4, or 8 (useful for array indexing)
* Offset = displacement constant (0x10 here)

This is extremely common in compiled code for accessing array elements and struct fields.


## 3. General Effective Address Formula

You wrote it in green:

```
EA = BR + IR * {1,2,4,8} + OFF
```

* BR = Base register (optional)
* IR = Index register (optional)
* Scale = multiplier (1, 2, 4, 8)
* OFF = constant displacement

Not all parts must be present. The CPU can decode any valid combination.


## 4. Real-World Example

Imagine a C array:

```c
int arr[10];
int i = 3;
int x = arr[i];
```

Compiler might generate:

```asm
mov eax, i
mov edx, arr
mov ecx, [edx + eax*4]   ; load arr[i] into ecx
```

* `edx` = base address of `arr`
* `eax` = index `i`
* `*4` = scale (because int = 4 bytes)


Perfect üëç let‚Äôs do a **comprehensive guide** of registers in **32-bit x86 (IA-32)** ‚Äî both general and special ‚Äî with clear explanations. This is exactly the foundation you need when reverse engineering.

---

# Registers in 32-bit x86

Registers are small, ultra-fast storage locations inside the CPU. In IA-32 there are:

---

## 1. General-Purpose Registers (GPRs)

Each 32-bit register can be accessed at different widths:

* **32-bit**: `EAX`
* **16-bit**: `AX`
* **8-bit high**: `AH`
* **8-bit low**: `AL`

Same pattern applies to `EAX`, `EBX`, `ECX`, `EDX`.

### List:

* **EAX** ‚Äî Accumulator

  * Used in arithmetic, multiplication/division, I/O, and function **return values**.

* **EBX** ‚Äî Base register

  * Often holds base addresses for memory access.

* **ECX** ‚Äî Counter

  * Used in loops and string instructions (`rep movsb` uses ECX as counter).

* **EDX** ‚Äî Data register

  * Extends EAX for 64-bit multiply/divide; also used in I/O port addressing.

* **ESI** ‚Äî Source Index

  * Used in string/memory operations as the source pointer.

* **EDI** ‚Äî Destination Index

  * Used in string/memory operations as the destination pointer.

* **EBP** ‚Äî Base Pointer (Frame Pointer)

  * Anchors the stack frame. Locals and arguments accessed relative to it.

* **ESP** ‚Äî Stack Pointer

  * Always points to top of stack. Critical for function calls/returns.

---

## 2. Instruction & Flags

* **EIP** (Instruction Pointer)

  * Holds the address of the **next instruction**.
  * Control flow (`jmp`, `call`, `ret`) changes this.
* **EFLAGS**

  * Status and control flags (carry, zero, sign, overflow, direction, interrupt enable, etc.).
  * Example: after `cmp eax, ebx`, the **Zero Flag** (ZF) tells if they were equal.

---

## 3. Segment Registers

Legacy, but still exist in 32-bit protected mode:

* **CS** ‚Äî Code Segment (used with EIP).
* **SS** ‚Äî Stack Segment (used with ESP/EBP).
* **DS** ‚Äî Data Segment (used for general memory).
* **ES** ‚Äî Extra Segment (string ops).
* **FS/GS** ‚Äî Often repurposed for OS-level/thread-local storage (TLS).

  * Example: Windows TEB (Thread Environment Block) is accessed via `FS`.

---

## 4. Control Registers (privileged, not user code)

These control memory management and CPU mode:

* **CR0** ‚Äî system control (enables paging, protected mode).
* **CR2** ‚Äî holds the faulting address on a page fault.
* **CR3** ‚Äî page directory base register (root of paging structures).
* **CR4** ‚Äî feature flags (enables extensions like SSE).

---

## 5. Debug Registers (for debugging / reverse engineering)

* **DR0‚ÄìDR3** ‚Äî hold linear addresses for breakpoints.
* **DR6** ‚Äî debug status.
* **DR7** ‚Äî debug control.

(Reverse engineers sometimes use these to set hardware breakpoints with tools like `gdb` or `WinDbg`.)

---

## 6. Special Registers (reverse engineering focus)

When analyzing **program execution** (stack traces, function calls, control flow), the most important registers are:

1. **EIP** ‚Äî Instruction Pointer

   * Tells you what instruction will execute next.
   * When you follow control flow in IDA/Ghidra, you‚Äôre tracking possible values of EIP.

2. **ESP** ‚Äî Stack Pointer

   * Tracks the runtime stack (function calls, local variables, return addresses).

3. **EBP** ‚Äî Base Pointer

   * Anchors the stack frame. Without it, reconstructing local variables is harder.

4. **EAX** ‚Äî Return value register

   * Functions usually return values here.

So for reverse engineering, the **core set you watch constantly** is:
`EIP`, `ESP`, `EBP`, `EAX`.

---

## 7. Other Registers Worth Noting

* **MMX Registers (MM0‚ÄìMM7)** ‚Äî used for multimedia instructions (packed ints).
* **XMM Registers (XMM0‚ÄìXMM7)** ‚Äî used for SSE (floating-point and SIMD operations).
* **FPU Registers (ST0‚ÄìST7)** ‚Äî floating point unit stack.

---

# Summary Table

| Category                | Registers                              | Purpose                         |
| ----------------------- | -------------------------------------- | ------------------------------- |
| General Purpose         | EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP | Arithmetic, data, stack, loops  |
| Instruction/Flags       | EIP, EFLAGS                            | Control flow, condition codes   |
| Segment Registers       | CS, SS, DS, ES, FS, GS                 | Memory segmentation, TLS        |
| Control Registers       | CR0, CR2, CR3, CR4                     | Paging, memory mgmt             |
| Debug Registers         | DR0‚ÄìDR3, DR6, DR7                      | Breakpoints                     |
| SIMD/FPU                | MM0‚ÄìMM7, XMM0‚ÄìXMM7, ST0‚ÄìST7            | Multimedia, floating point      |
| **Most Important (RE)** | **EIP, ESP, EBP, EAX**                 | Execution flow & stack analysis |

---

**Key clarifications for you**:

* `%ax` does **not** store the return address ‚Äî the **stack** holds it, and `ret` pops it into **EIP**.
* `%eax` holds **function return values**, not addresses.
* The **two most critical registers** for reverse engineering stack frames are **EIP** (execution) and **EBP/ESP** (stack tracking).